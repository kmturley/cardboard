<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Cardboard Example</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        margin: 0px;
        overflow: hidden;
      }
      #example {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
      }
    </style>
  </head>
  <body>
    <div id="example"></div>

  <script src="js/third-party/threejs/three.js"></script>
  <script src="js/third-party/threejs/StereoEffect.js"></script>
  <script src="js/third-party/threejs/DeviceOrientationControls.js"></script>
<!--  <script src="js/third-party/threejs/OrbitControls.js"></script>-->
    <script src="js/PointerLockControls.js"></script>
    <script src="js/cannon.js"></script>

  <script>
    var camera, scene, renderer;
    var effect, controls;
    var element, container;
    var time = Date.now();

    var sphereShape, sphereBody, world, physicsMaterial, walls=[], balls=[], ballMeshes=[], boxes=[], boxMeshes=[], material;

    var clock = new THREE.Clock();

    initCannon();
    init();
    animate();

      function initCannon(){
            // Setup our world
            world = new CANNON.World();
            world.quatNormalizeSkip = 0;
            world.quatNormalizeFast = false;

            var solver = new CANNON.GSSolver();

            world.defaultContactMaterial.contactEquationStiffness = 1e9;
            world.defaultContactMaterial.contactEquationRelaxation = 4;

            solver.iterations = 7;
            solver.tolerance = 0.1;
            var split = true;
            if(split)
                world.solver = new CANNON.SplitSolver(solver);
            else
                world.solver = solver;

            world.gravity.set(0,-20,0);
            world.broadphase = new CANNON.NaiveBroadphase();

            // Create a slippery material (friction coefficient = 0.0)
            physicsMaterial = new CANNON.Material("slipperyMaterial");
            var physicsContactMaterial = new CANNON.ContactMaterial(physicsMaterial,
                                                                    physicsMaterial,
                                                                    0.0, // friction coefficient
                                                                    0.3  // restitution
                                                                    );
            // We must add the contact materials to the world
            world.addContactMaterial(physicsContactMaterial);

            // Create a sphere
            var mass = 5, radius = 1.3;
            sphereShape = new CANNON.Sphere(radius);
            sphereBody = new CANNON.Body({ mass: mass });
            sphereBody.addShape(sphereShape);
            sphereBody.position.set(0,5,0);
            sphereBody.linearDamping = 0.9;
            world.add(sphereBody);

            // Create a plane
            var groundShape = new CANNON.Plane();
            var groundBody = new CANNON.Body({ mass: 0 });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
            world.add(groundBody);
        }

    function init() {
      renderer = new THREE.WebGLRenderer();
    renderer.shadowMapEnabled = true;
    renderer.shadowMapSoft = true;
      element = renderer.domElement;
      container = document.getElementById('example');
      container.appendChild(element);

      effect = new THREE.StereoEffect(renderer);

      scene = new THREE.Scene();

      //camera = new THREE.PerspectiveCamera(90, 1, 0.001, 700);
        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
//      camera.position.set(0, 0, 0);
      scene.add(camera);

//      controls = new THREE.OrbitControls(camera, element);
//      controls.rotateUp(Math.PI / 4);
//      controls.target.set(
//        camera.position.x + 0.1,
//        camera.position.y,
//        camera.position.z
//      );
//      controls.noZoom = true;
//      controls.noPan = true;

    controls = new PointerLockControls( camera , sphereBody );
        controls.enabled = true;
    scene.add( controls.getObject() );

      function setOrientationControls(e) {
        if (!e.alpha) {
          return;
        }

        controls = new THREE.DeviceOrientationControls(camera, true);
        controls.connect();
        controls.update();

        element.addEventListener('click', fullscreen, false);

        window.removeEventListener('deviceorientation', setOrientationControls, true);
      }
      window.addEventListener('deviceorientation', setOrientationControls, true);


      var light = new THREE.HemisphereLight(0x777777, 0x000000, 0.6);
      scene.add(light);

      var texture = THREE.ImageUtils.loadTexture(
        'textures/patterns/checker.png'
      );
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.repeat = new THREE.Vector2(50, 50);
      texture.anisotropy = renderer.getMaxAnisotropy();

      material = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        specular: 0xffffff,
        shininess: 20,
        shading: THREE.FlatShading,
        map: texture
      });

      var geometry = new THREE.PlaneGeometry(1000, 1000);

      var mesh = new THREE.Mesh(geometry, material);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
      mesh.rotation.x = -Math.PI / 2;
      scene.add(mesh);

      window.addEventListener('resize', resize, false);
      setTimeout(resize, 1);

            // Add boxes
            var halfExtents = new CANNON.Vec3(1,1,1);
            var boxShape = new CANNON.Box(halfExtents);
            var boxGeometry = new THREE.BoxGeometry(halfExtents.x*2,halfExtents.y*2,halfExtents.z*2);
            for(var i=0; i<7; i++){
                var x = (Math.random()-0.5)*20;
                var y = 1 + (Math.random()-0.5)*1;
                var z = (Math.random()-0.5)*20;
                var boxBody = new CANNON.Body({ mass: 5 });
                boxBody.addShape(boxShape);
                var boxMesh = new THREE.Mesh( boxGeometry, material );
                world.add(boxBody);
                scene.add(boxMesh);
                boxBody.position.set(x,y,z);
                boxMesh.position.set(x,y,z);
                boxMesh.castShadow = true;
                boxMesh.receiveShadow = true;
                boxes.push(boxBody);
                boxMeshes.push(boxMesh);
            }


            // Add linked boxes
            var size = 0.5;
            var he = new CANNON.Vec3(size,size,size*0.1);
            var boxShape = new CANNON.Box(he);
            var mass = 0;
            var space = 0.1 * size;
            var N = 5, last;
            var boxGeometry = new THREE.BoxGeometry(he.x*2,he.y*2,he.z*2);
            for(var i=0; i<N; i++){
                var boxbody = new CANNON.Body({ mass: mass });
                boxbody.addShape(boxShape);
                var boxMesh = new THREE.Mesh(boxGeometry, material);
                boxbody.position.set(5,(N-i)*(size*2+2*space) + size*2+space,0);
                boxbody.linearDamping = 0.01;
                boxbody.angularDamping = 0.01;
                // boxMesh.castShadow = true;
                boxMesh.receiveShadow = true;
                world.add(boxbody);
                scene.add(boxMesh);
                boxes.push(boxbody);
                boxMeshes.push(boxMesh);

                if(i!=0){
                    // Connect this body to the last one
                    var c1 = new CANNON.PointToPointConstraint(boxbody,new CANNON.Vec3(-size,size+space,0),last,new CANNON.Vec3(-size,-size-space,0));
                    var c2 = new CANNON.PointToPointConstraint(boxbody,new CANNON.Vec3(size,size+space,0),last,new CANNON.Vec3(size,-size-space,0));
                    world.addConstraint(c1);
                    world.addConstraint(c2);
                } else {
                    mass=0.3;
                }
                last = boxbody;
            }

      }

    function resize() {
      var width = container.offsetWidth;
      var height = container.offsetHeight;

      camera.aspect = width / height;
      camera.updateProjectionMatrix();

      renderer.setSize(width, height);
      effect.setSize(width, height);
    }

    function update(dt) {
      resize();

      camera.updateProjectionMatrix();

      controls.update(dt);
    }

    function render(dt) {
        renderer.render( scene, camera );
      effect.render(scene, camera);
    }

    function animate() {
      requestAnimationFrame(animate);

        if(controls.enabled){
            world.step(1/60);

            // Update ball positions
            for(var i=0; i<balls.length; i++){
                ballMeshes[i].position.copy(balls[i].position);
                ballMeshes[i].quaternion.copy(balls[i].quaternion);
            }

            // Update box positions
            for(var i=0; i<boxes.length; i++){
                boxMeshes[i].position.copy(boxes[i].position);
                boxMeshes[i].quaternion.copy(boxes[i].quaternion);
            }
        }


//        renderer.render( scene, camera );
//        controls.update( Date.now() - time );

          update(Date.now() - time);
          render(Date.now() - time);
        time = Date.now();
    }

    function fullscreen() {
      if (container.requestFullscreen) {
        container.requestFullscreen();
      } else if (container.msRequestFullscreen) {
        container.msRequestFullscreen();
      } else if (container.mozRequestFullScreen) {
        container.mozRequestFullScreen();
      } else if (container.webkitRequestFullscreen) {
        container.webkitRequestFullscreen();
      }
    }

      var ballShape = new CANNON.Sphere(0.2);
            var ballGeometry = new THREE.SphereGeometry(ballShape.radius, 32, 32);
            var shootDirection = new THREE.Vector3();
            var shootVelo = 15;
            var projector = new THREE.Projector();
            function getShootDir(targetVec){
                var vector = targetVec;
                targetVec.set(0,0,1);
                projector.unprojectVector(vector, camera);
                var ray = new THREE.Ray(sphereBody.position, vector.sub(sphereBody.position).normalize() );
                targetVec.copy(ray.direction);
            }

            window.addEventListener("click",function(e){
                if(controls.enabled==true){
                    console.log('click!');
                    var x = sphereBody.position.x;
                    var y = sphereBody.position.y;
                    var z = sphereBody.position.z;
                    var ballBody = new CANNON.Body({ mass: 1 });
                    ballBody.addShape(ballShape);
                    var ballMesh = new THREE.Mesh( ballGeometry, material );
                    world.add(ballBody);
                    scene.add(ballMesh);
                    ballMesh.castShadow = true;
                    ballMesh.receiveShadow = true;
                    balls.push(ballBody);
                    ballMeshes.push(ballMesh);
                    getShootDir(shootDirection);
                    ballBody.velocity.set(  shootDirection.x * shootVelo,
                                            shootDirection.y * shootVelo,
                                            shootDirection.z * shootVelo);

                    // Move the ball outside the player sphere
                    x += shootDirection.x * (sphereShape.radius*1.02 + ballShape.radius);
                    y += shootDirection.y * (sphereShape.radius*1.02 + ballShape.radius);
                    z += shootDirection.z * (sphereShape.radius*1.02 + ballShape.radius);
                    ballBody.position.set(x,y,z);
                    ballMesh.position.set(x,y,z);
                }
            });
  </script>
  </body>
</html>
